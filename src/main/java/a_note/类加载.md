# **`类加载`**
### `类加载过程`
#####类的生命周期：
    加载 -> 连接 -> 初始化 -> 使用 -> 卸载
           /  \
      验证->准备->解析
    类加载的过程:加载->连接->初始化 
#####加载:
    1.通过全类名获取定义此类的二进制字节流
    2.将字节流所代表的静态存储结构转换为方法区的运行时的数据结构
    3.在内存中生成一个代表该类的class对象,作为方法区这些数据的访问入口
    
    一个非数组类的加载阶段是可控性最强的阶段,这一步我们可以去完成
    还可以自定义类加载器去控制字节流的获取方式,重写一个loadClass方法
    数组类型不通过类加载器创建,而是由Java虚拟机直接创建.
    加载阶段和连接阶段的部分内容是交叉进行的,加载阶段尚未结束,连接阶段可能就已经开始了.
#####验证:
    文件格式验证->元数据验证->字节码验证->符号引用验证
    文件格式验证: 验证字节流是否符合class文件格式的规范
    元数据彦验证: 对字节码描述的信息进行语义分析,以保证其描述的信息符合Java语言的规范要求
    字节码验证: 通过数据流和控制流分析,确定程序语义是合法的符合逻辑的
    符号引用验证: 确保解析动作能正常运行
#####准备:
    准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,这些内存都将在方法区中分配.
    这个时候进行的内存分配只是类变量即静态变量,被static修饰的变量,只与类相关,不包括实例变量.实例变量在对象进行实例化时随着对象一块在堆中分配.
    类变量所使用的内存都应当在方法区中进行分配.
    注意：
        JDK7之前HotSpot使用永久代来实现方法区的时候,实现是完全符合这种逻辑概念的,
        在JDK7及之后,HotSpot已经把原本放在永久代的字符串常量池静态变量等移动到堆中,这个时候类变量则会随着 Class 对象一起存放在 Java 堆中.
    这所设置的初始值"通常情况"下是数据类型默认的零值如0L null false 等,比如我们定义了public static int value=111,
    那么value变量在准备阶段的初始值就是0而不是 111（初始化阶段才会赋值）.
    特殊情况：比如给value变量加上了final关键字public static final int value=111,那么准备阶段value的值就被赋值为111.
#####解析:
    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程,就是得到类或者字段、方法在内存中的指针或者偏移量.
    主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行
    符号引用就是一组符号来描述目标,可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄.
#####初始化:
    初始化阶段是执行初始化方法clinit方法的过程,cliniti方法时变异之后自定生成的.是类加载的最后一步,这时候jvm才开始真正的执行类中定义的程序代码.
    初始化阶段,虚拟机严格规范了有且只有5种情况下,必须对类进行初始化(只有主动去使用类才会初始化类):
    1.遇到new,getstatic,putstatic,invokestatic这四条直接码指令时,new一个类,读取一个静态字段(未被final修饰)、或调用一个类的静态方法时。
        执行new指令时会初始化类,创建一个类的实例化对象
        执行getstatic,访问类的静态变量(不是静态常量,常量会被加载到运行时常量池)
        执行putstatic,给类的静态变量赋值
        执行invokestatic,调用类的静态方法
    2.使用java.lang.reflect包的方法对类进行反射调用时如 Class.forname(), newInstance()等.如果类没初始化,需要触发其初始化
    3.初始化一个类,其父类还未被初始化,则将先进行父类的初始化
    4.当虚拟机启动时,用户需要定义一个要执行的主类虚拟机将会先初始化这个类
    5.MethodHandle和VarHandle可以看作是轻量级的反射调用机制,而要想使用这2个调用,就必须先使用findStaticVarHandle来初始化要调用的类
    6.当一个接口中定义了被default关键字修饰的接口方法时,如果有这个接口的实现类发生了初始化,那该接口要在其之前被初始化
#####使用: 
    程序中的使用
#####卸载:
    卸载类即该类的Class对象被GC
    1.该类的所有实例化对象全部都被GC,堆内将不存在该类的实例对象
    2.该类没有被其他的地方所引用
    3.该类的类加载器的实例已经被GC
    在JVM生命周期内,由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。
    jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类,
    所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的,使用我们自定义加载器加载的类是可以被卸载掉的

###`类加载器`
#####类加载器
    BootstrapClassLoader(启动类加载器)：最顶层的加载类,由C++实现,负责加载%JAVA_HOME%/lib目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类。
    ExtensionClassLoader(扩展类加载器)：主要负责加载%JRE_HOME%/lib/ext目录下的jar包和类,或被java.ext.dirs系统变量所指定的路径下的jar包。
    AppClassLoader(应用程序类加载器)：面向我们用户的加载器,负责加载当前应用classpath下的所有jar包和类
    UserDefinedClassLoader(自定义类加载器)
#####双亲委派模型:
    每一个类都有自己的类加载器,系统中默认使用双亲委派模型.在类加载的过程中系统会首先判定当前类有没有被加载.
    已经被加载过的就直接返回,否则继续尝试加载.
    加载的时候，首先会把该请求委派给父类加载器的loadClass()处理，因此所有的请求最终都应该传送到顶层的启动类加载器BootstrapClassLoader中。
    当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器BootstrapClassLoader作为父类加载器。
  
    双亲委派的好处:
    双亲委派模型保证了Java程序的稳定运行,可以避免类的重复加载JVM区分不同类的方式不仅仅根据类名,相同的类文件被不同的类加载器加载产生的是两个不同的类
    自定义类加载器:
    需继承ClassLoader,如果不想打破双亲委派模型,就重写ClassLoader类中的findClass()方法即可,无法被父类加载器加载的类最终会通过这个方法被加载
    但如果想打破双亲委派模型则需要重写loadClass()方法
    
 
