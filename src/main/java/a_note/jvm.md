# **JVM**
    程序计数器,本地方法栈,虚拟机栈,1.8之前方法区1.8元空间,堆,运行时常量池,字符串常量池,直接内存
    JDK1.8之前 方法区 运行时常量池
    JDK1.8 元空间
    线程私有:
        程序计数器,虚拟机栈,本地方法栈
    线程共享:
        堆,直接内存,方法区
        
运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念,是公共且抽象的
Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念,是私有且具体的
#####程序计数器:
    当前线程执行的字节码行号指示器,每个线程有着自己独立的程序计数器,能在进行上下文切换的时候恢复到上次所执行的位置.
    1.主要控制于代码的执行流程2.在多线程的情况下切换上下文时恢复到上次所执行的位置.
#####虚拟机栈,本地方法栈:
    栈线程私有,随着线程的创建而创建结束而结束,方法的调用数据需要通过栈来进行传递,
    每一次的方法调用将会有对应的一个栈帧被压入栈中,每一次的方法结束都将会有一个栈帧被弹出.
    栈由一个个的栈帧所组成,栈帧包括有局部变量表,操作数栈,动态链接,方法返回的地址.
        局部变量表:
            存放的是编译期间可知的各种数据类型(boolean,int,byte,char,long,double,float,short)
        对象引用(reference类型,不同于对象本身,它可能是一个指向对象起始地址的引用指针,可能是指向一个代表对象的句柄或其他与此对象相关的位置)
        操作数栈:
            作为方法调用的中转站使用,存放方法执行过程中产生的中间计算结果,计算过程中产生的临时变量也会放在操作数栈中.
        动态链接:
            一个方法需要调用其他方法,动态链接的作用就是为了将符号引用转换为调用方法的直接引用
            在源文件中被编译成字节码的时候所有的变量和方法引用都作为符号引用保存在class文件的常量池里,
            当一个方法要调用其他方法时,需要将常量池中指向方法的符号引用转化成它在内存地址中的直接引用.
        方法返回的地址:
            1.return 2.抛异常 销毁栈帧
        StackOverFlowError 若栈的内存大小不允许动态扩展,那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时就抛出该异常
        OutOfMemoryError 栈的内存大小可以动态扩展,如果虚拟机在动态扩展栈时无法申请到足够的内存空间就抛出该异常
#####堆:
    存放对象实例,几乎所有的对象实例以及数组都在堆内分配内存,GC回收的主要区域可分为新生代、老年代;eden,survivor,old区
    逃逸分析:如果某些方法中的对象引用没有被返回或者未被外面使用也就是未逃逸出去,那么对象可以直接在栈上分配内存
    JDK1.7
        新生代内存(Young Generation) Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代
        老生代(Old Generation)
        永久代(Permanent Generation)
    JDK1.8
        JDK8版本之后Metaspace(元空间)取代PermGen,元空间使用的是直接内存
    大部分情况对象都会首先在Eden区域分配,在一次新生代垃圾回收后,如果对象还存活则会进入S0或者S1,
    并且对象的年龄还会加1(Eden区->Survivor区后对象的初始年龄变为1),当它的年龄增加到一定程度(默认为15岁),
    就会被晋升到老年代中.对象晋升到老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold来设置
    java.lang.OutOfMemoryError: GC Overhead Limit Exceeded
        当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时,就会发生此错误
    java.lang.OutOfMemoryError: Java heap space
        假如在创建新的对象时,堆内存中的空间不足以存放新创建的对象,就会引发此错误
        (和配置的最大堆内存有关,且受制于物理内存大小.最大堆内存可通过-Xmx参数配置,若没有特别配置,将会使用默认值)
#####方法区:
    是JVM运行时数据区域的一块逻辑区域
    当虚拟机要使用一个类时,它需要读取并解析Class文件获取相关信息,再将信息存入到方法区
    方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据
    方法区和永久代以及元空间类似于接口和类的关系,类实现了接口,类可以看作为永久代和元空间,接口可以看作为方法区,
    永久代和元空间是方法区的两种实现方式.
    为什么将元空间取代永久代?
        1、整个永久代有一个JVM本身设置的固定大小上限,无法进行调整,
        而元空间使用的是直接内存,受本机可用内存的限制,虽然元空间仍旧可能溢出,但是比原来出现的几率会更小
        当元空间溢出时会得到如下错误: java.lang.OutOfMemoryError: MetaSpace
        可以使用-XX:MaxMetaspaceSize标志设置最大元空间大小,默认值为unlimited,这意味着它只受系统内存的限制
        -XX:MetaspaceSize调整标志定义元空间的初始大小如果未指定此标志,则Metaspace将根据运行时的应用程序需求动态地重新调整大小
        2、元空间里面存放的是类的元数据,这样加载多少类的元数据就不由MaxPermSize控制,而由系统的实际可用空间来控制,这样能加载的类就更多了
        3、在JDK8,合并HotSpot和JRockit的代码时,JRockit从来没有一个叫永久代的东西,合并之后就没有必要额外的设置这么一个永久代的地方了
    -XX:MetaspaceSize=N //设置Metaspace的初始最小大小
    -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
    与永久代很大的不同就是,如果不指定大小,随着更多类的创建,虚拟机会耗尽所有可用的系统内存

#####运行时常量池,字符串常量池:
    Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有用于存放编译期生成的各种字面量和符号引用的常量池表
    字面量是源代码中的固定值的表示法,即通过字面我们就能知道其值的含义.字面量包括整数、浮点数和字符串字面量
    符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用.
    运行时常量池是方法区的一部分,常量池表会在类加载后存放到方法区的运行时常量池中
    字符串常量池是JVM为了提升性能和减少内存消耗针对字符串String类专门开辟的一块区域,目的是为了避免字符串的重复创建
    JDK1.7为什么要将字符串常量池移动到堆中?
        主要是因为永久代的GC回收效率太低,只有在整堆收集(Full GC)的时候才会被执行GC.
        Java程序中通常会有大量的被创建的字符串等待回收,将字符串常量池放到堆中,能够更高效及时地回收字符串内存.
#####直接内存:


#####对象的创建
    1.类加载检查
        虚拟机在遇到一条new指令时,首先先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用,
        并且检查这个符号引用的类是否已被加载,解析和初始化过.如果没有,那么必须先执行相应的类加载过程.
    2.分配内存
        类加载检查通过后,虚拟机将为新生对象分配内存.对象所需的内存大小在类加载完成后便可确定,把一块确定大小的内存从堆中划分出来.
        分配方式有 “指针碰撞” 和 “空闲列表” 两种,选择哪种分配方式由堆是否规整决定,堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定.
        指针碰撞:
            堆内存规整即没有内存碎片的情况下,用过的内存全部整合到一边,没有用过的内存放在另一边,
            中间有一个分界指针,只需要向着没用过的内存方向将该指针移动对象内存大小位置即可
            使用该分配方式的 GC 收集器:Serial, ParNew
        空闲列表:
            堆内存不规整的情况下,虚拟机会维护一个列表,该列表中会记录哪些内存块是可用的,
            在分配的时候,找一块儿足够大的内存块儿来划分给对象实例,最后更新列表记录.
            使用该分配方式的 GC 收集器:CMS
        并发问题:
        在创建对象的时候有一个很重要的问题,就是线程安全,因为在实际开发过程中,创建对象是很频繁的事情,作为虚拟机来说,必须要保证线程是安全的
        通常来讲,虚拟机采用两种方式来保证线程安全:
        CAS+失败重试:CAS 是乐观锁的一种实现方式.所谓乐观锁就是,每次不加锁而是假设没有冲突而去完成某项操作,
        如果因为冲突失败就重试,直到成功为止.虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性.
        TLAB: 为每一个线程预先在 Eden 区分配一块儿内存,JVM 在给线程中的对象分配内存时,
        首先在 TLAB 分配,当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时,再采用上述的 CAS 进行内存分配
    3.初始化零值
        内存分配完成后,虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）,
        这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用,程序能访问到这些字段的数据类型所对应的零值.
    4.设置对象头
        初始化零值完成之后,虚拟机要对对象进行必要的设置,
        例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息. 
        这些信息存放在对象头中. 另外,根据虚拟机当前运行状态的不同,如是否启用偏向锁等,对象头会有不同的设置方式.
    5.执行 init 方法
        在上面工作都完成之后,从虚拟机的视角来看,一个新的对象已经产生了
        但从 Java 程序的视角来看,对象创建才刚开始,<init> 方法还没有执行,所有的字段都还为零.
        所以一般来说,执行 new 指令之后会接着执行 <init> 方法,把对象按照程序员的意愿进行初始化,这样一个真正可用的对象才算完全产生出来.
    
    对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充
        对象头包括两部分信息:
        第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）
        另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
        实例数据部分:
        对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容
        对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用
    访问对象
        句柄:
            堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。
        直接指针:
            堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址
        使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。
        使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
