# **JVM**
    程序计数器,本地方法栈,虚拟机栈,1.8之前方法区1.8元空间,堆,运行时常量池,字符串常量池,直接内存
    JDK1.8之前 方法区 运行时常量池
    JDK1.8 元空间
    线程私有:
        程序计数器,虚拟机栈,本地方法栈
    线程共享:
        堆,直接内存,方法区
        
运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念,是公共且抽象的
Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念,是私有且具体的
#####程序计数器:
    当前线程执行的字节码行号指示器,每个线程有着自己独立的程序计数器,能在进行上下文切换的时候恢复到上次所执行的位置.
    1.主要控制于代码的执行流程2.在多线程的情况下切换上下文时恢复到上次所执行的位置.
#####虚拟机栈,本地方法栈:
    栈线程私有,随着线程的创建而创建结束而结束,方法的调用数据需要通过栈来进行传递,
    每一次的方法调用将会有对应的一个栈帧被压入栈中,每一次的方法结束都将会有一个栈帧被弹出.
    栈由一个个的栈帧所组成,栈帧包括有局部变量表,操作数栈,动态链接,方法返回的地址.
        局部变量表:
            存放的是编译期间可知的各种数据类型(boolean,int,byte,char,long,double,float,short)
        对象引用(reference类型,不同于对象本身,它可能是一个指向对象起始地址的引用指针,可能是指向一个代表对象的句柄或其他与此对象相关的位置)
        操作数栈:
            作为方法调用的中转站使用,存放方法执行过程中产生的中间计算结果,计算过程中产生的临时变量也会放在操作数栈中.
        动态链接:
            一个方法需要调用其他方法,动态链接的作用就是为了将符号引用转换为调用方法的直接引用
            在源文件中被编译成字节码的时候所有的变量和方法引用都作为符号引用保存在class文件的常量池里,
            当一个方法要调用其他方法时,需要将常量池中指向方法的符号引用转化成它在内存地址中的直接引用.
        方法返回的地址:
            1.return 2.抛异常 销毁栈帧
        StackOverFlowError 若栈的内存大小不允许动态扩展,那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时就抛出该异常
        OutOfMemoryError 栈的内存大小可以动态扩展,如果虚拟机在动态扩展栈时无法申请到足够的内存空间就抛出该异常
#####堆:
    存放对象实例,几乎所有的对象实例以及数组都在堆内分配内存,GC回收的主要区域可分为新生代、老年代;eden,survivor,old区
    逃逸分析:如果某些方法中的对象引用没有被返回或者未被外面使用也就是未逃逸出去,那么对象可以直接在栈上分配内存
    JDK1.7
        新生代内存(Young Generation) Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代
        老生代(Old Generation)
        永久代(Permanent Generation)
    JDK1.8
        JDK8版本之后Metaspace(元空间)取代PermGen,元空间使用的是直接内存
    大部分情况对象都会首先在Eden区域分配,在一次新生代垃圾回收后,如果对象还存活则会进入S0或者S1,
    并且对象的年龄还会加1(Eden区->Survivor区后对象的初始年龄变为1),当它的年龄增加到一定程度(默认为15岁),
    就会被晋升到老年代中.对象晋升到老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold来设置
    java.lang.OutOfMemoryError: GC Overhead Limit Exceeded
        当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时,就会发生此错误
    java.lang.OutOfMemoryError: Java heap space
        假如在创建新的对象时,堆内存中的空间不足以存放新创建的对象,就会引发此错误
        (和配置的最大堆内存有关,且受制于物理内存大小.最大堆内存可通过-Xmx参数配置,若没有特别配置,将会使用默认值)
#####方法区:
    是JVM运行时数据区域的一块逻辑区域
    当虚拟机要使用一个类时,它需要读取并解析Class文件获取相关信息,再将信息存入到方法区
    方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据
    方法区和永久代以及元空间类似于接口和类的关系,类实现了接口,类可以看作为永久代和元空间,接口可以看作为方法区,
    永久代和元空间是方法区的两种实现方式.
    为什么将元空间取代永久代?
        1、整个永久代有一个JVM本身设置的固定大小上限,无法进行调整,
        而元空间使用的是直接内存,受本机可用内存的限制,虽然元空间仍旧可能溢出,但是比原来出现的几率会更小
        当元空间溢出时会得到如下错误: java.lang.OutOfMemoryError: MetaSpace
        可以使用-XX：MaxMetaspaceSize标志设置最大元空间大小,默认值为unlimited,这意味着它只受系统内存的限制
        -XX：MetaspaceSize调整标志定义元空间的初始大小如果未指定此标志,则Metaspace将根据运行时的应用程序需求动态地重新调整大小
        2、元空间里面存放的是类的元数据,这样加载多少类的元数据就不由MaxPermSize控制,而由系统的实际可用空间来控制,这样能加载的类就更多了
        3、在JDK8,合并HotSpot和JRockit的代码时,JRockit从来没有一个叫永久代的东西,合并之后就没有必要额外的设置这么一个永久代的地方了
    -XX:MetaspaceSize=N //设置Metaspace的初始最小大小
    -XX:MaxMetaspaceSize=N //设置Metaspace的最大大小
    与永久代很大的不同就是,如果不指定大小,随着更多类的创建,虚拟机会耗尽所有可用的系统内存

#####运行时常量池,字符串常量池:
    Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有用于存放编译期生成的各种字面量和符号引用的常量池表
    字面量是源代码中的固定值的表示法,即通过字面我们就能知道其值的含义.字面量包括整数、浮点数和字符串字面量
    符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用.
    运行时常量池是方法区的一部分,常量池表会在类加载后存放到方法区的运行时常量池中
    字符串常量池是JVM为了提升性能和减少内存消耗针对字符串String类专门开辟的一块区域,目的是为了避免字符串的重复创建
    JDK1.7为什么要将字符串常量池移动到堆中?
        主要是因为永久代的GC回收效率太低,只有在整堆收集(Full GC)的时候才会被执行GC。
        Java程序中通常会有大量的被创建的字符串等待回收,将字符串常量池放到堆中,能够更高效及时地回收字符串内存。
#####直接内存:

