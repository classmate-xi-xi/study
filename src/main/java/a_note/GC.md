# **GC**
##### **如何判断对象是否死亡**
    可达性算法
        GC Roots对象作为起点 寻找是否有可以到达Roots的引用链 如果没有说明对象可以被回收
        缓刑:可达性分析法中不可达的对象被第一次标记并且进行一次筛选,
        筛选的条件是此对象是否有必要执行finalize方法,当对象没有覆盖finalize方法,
        或finalize方法已经被虚拟机调用过时,虚拟机将这两种情况视为没有必要执行
    引用计数法 
        当前对象是否有被使用 有使用就将其计数器加一 引用失效就减一 当为0时就说明对象可以被回收
        循环引用问题 比如 a->b b->a 但除了他们之间的相互引用没有别的对象对他们进行引用

#####**强引用、软引用、弱引用、虚引用**
    强引用:
        以前我们使用的大部分引用实际上都是强引用,这是使用最普遍的引用.一个对象具有强引用,
        那就类似于必不可少的生活用品,垃圾回收器绝不会回收它.当内存空间不足,
        Java 虚拟机宁愿抛出 OutOfMemoryError 错误,使程序异常终止,
        也不会靠随意回收具有强引用的对象来解决内存不足问题.
    软引用:
        如果一个对象只具有软引用,那就类似于可有可无的生活用品.
        如果内存空间足够,垃圾回收器就不会回收它,如果内存空间不足了,就会回收这些对象的内存.
        只要垃圾回收器没有回收它,该对象就可以被程序使用.软引用可用来实现内存敏感的高速缓存.
        软引用可以和一个引用队列（ReferenceQueue）联合使用,
        如果软引用所引用的对象被垃圾回收,JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中.
    弱引用:
        弱引用与软引用的区别在于:只具有弱引用的对象拥有更短暂的生命周期.
        在垃圾回收器线程扫描它所管辖的内存区域的过程中,
        一旦发现了只具有弱引用的对象,不管当前内存空间足够与否,都会回收它的内存.
        不过,由于垃圾回收器是一个优先级很低的线程,因此不一定会很快发现那些只具有弱引用的对象.
        弱引用可以和一个引用队列（ReferenceQueue）联合使用,
        如果弱引用所引用的对象被垃圾回收,虚拟机就会把这个弱引用加入到与之关联的引用队列中.
    虚引用:
        就是形同虚设,与其他几种引用都不同,虚引用并不会决定对象的生命周期.
        如果一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收.
        虚引用主要用来跟踪对象被垃圾回收的活动.
        虚引用与软引用和弱引用的一个区别在于:虚引用必须和引用队列联合使用.当垃圾回收器准备回收一个对象时,
        如果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中.
        程序可以通过判断引用队列中是否已经加入了虚引用,来了解被引用的对象是否将要被垃圾回收.
        程序如果发现某个虚引用已经被加入到引用队列,那么就可以在所引用的对象的内存被回收之前采取必要的行动.
        特别注意,在程序设计中一般很少使用弱引用与虚引用,使用软引用的情况较多,
        这是因为软引用可以加速JVM对垃圾内存的回收速度,
        可以维护系统的运行安全,防止内存溢出（OutOfMemory）等问题的产生.
#####**如何判断一个常量是废弃常量/如何判断一个类是无用的类**
    运行时常量池主要回收的是废弃的常量
        比如一个"abc"字符串,如果当前没有任何String对象引用其的话,就说明它是一个废弃常量
        在这时候如果发生了内存回收,那么它就会被清出常量池
    方法区主要回收的是无用的类
        类需要同时满足下面3个条件才能算是“无用的类”
        1.该类所有的实例都已经被回收,也就是 Java 堆中不存在该类的任何实例.
        2.加载该类的 ClassLoader 已经被回收.
        3.该类对应的 java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.
#####**垃圾收集算法**
    标记-清除算法
        首先标记出所有不需要回收的对象,在标记完成后统一回收掉所有没有被标记的对象.
        会带来效率问题,空间问题 标记清除后会产生大量不连续的碎片
    标记-复制算法
        为了解决效率问题,“标记-复制”收集算法出现了.它可以将内存分为大小相同的两块,每次使用其中的一块.
        当这一块的内存使用完后,就将还存活的对象复制到另一块去,然后再把使用的空间一次清理掉.
        这样就使每次的内存回收都是对内存区间的一半进行回收.
    标记-整理算法
        根据老年代的特点提出的一种标记算法,标记过程与“标记-清除”算法一样,
        让所有存活的对象向一端移动,然后直接清理掉端边界以外的内存.
    分代收集算法
        根据对象存活周期的不同将内存分为几块,一般将 java 堆分为新生代和老年代
        比如在新生代中,每次收集都会有大量对象死去,所以可以选择”标记-复制“算法,只需要付出少量对象的复制成本就可以完成每次垃圾收集.
        老年代的对象存活几率是比较高的,而且没有额外的空间对它进行分配担保,所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集.
#####**垃圾收集器**
    Serial收集器--简单而高效,没有线程交互的开销,对于运行在 Client 模式下的虚拟机来说是个不错的选择
        是一个单线程收集器.它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作,
        更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（"Stop The World"）,直到它收集结束.
        新生代采用标记-复制算法,老年代采用标记-整理算法.
        
    ParNew收集器--Serial收集器的多线程版本,是许多运行在Server模式下的虚拟机的首要选择,除了Serial外,只有它能与CMS收集器配合工作
        除了使用多线程进行垃圾收集外,其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样
        新生代采用标记-复制算法,老年代采用标记-整理算法.
        
    Parallel Scavenge收集器--使用标记-复制算法的多线程收集器,是 JDK1.8 默认收集器
        它的关注点是吞吐量（高效率的利用 CPU）,吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值
        提供了很多参数供用户找到最合适的停顿时间或最大吞吐量,如果对于收集器运作不太了解,手工优化存在困难的时候,
        使用 Parallel Scavenge 收集器配合自适应调节策略,把内存管理优化交给虚拟机去完成
        JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old
        如果指定了-XX:+UseParallelGC参数,则默认指定了-XX:+UseParallelOldGC,可以使用-XX:-UseParallelOldGC来禁用该功能
        新生代采用标记-复制算法,老年代采用标记-整理算法.
        
    Serial Old 收集器--Serial 收集器的老年代版本
        同样是一个单线程收集器.它主要有两大用途:
            一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用,另一种用途是作为CMS收集器的后备方案
    
    Parallel Old 收集器--Parallel Scavenge 收集器的老年代版本
        使用多线程和“标记-整理”算法.
        在注重吞吐量以及CPU资源的场合,都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器.
        
    CMS 收集器--以获取最短回收停顿时间为目标的收集器,它非常符合在注重用户体验的应用上使用
        HotSpot 虚拟机第一款真正意义上的并发收集器,它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作
        CMS 收集器是以 “标记-清除” 算法实现的
        1.初始标记: 暂停所有的其他线程,并记录下直接与 root 相连的对象,速度很快
        2.并发标记: 同时开启GC和用户线程,用一个闭包结构去记录可达对象.在这个阶段结束,这个闭包结构并不能保证包含当前所有的可达对象.
        因为用户线程可能会不断的更新引用域,所以GC线程无法保证可达性分析的实时性.所以这个算法里会跟踪记录这些发生引用更新的地方.
        3.重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录,
        这个阶段的停顿时间一般会比初始标记阶段的时间稍长,远远比并发标记阶段时间短
        4.并发清除: 开启用户线程,同时GC线程开始对未标记的区域做清扫.
        
        优点是:并发收集、低停顿.
        明显的缺点: 对 CPU 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生.
        
    G1 收集器--面向服务器的垃圾收集器
        主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.   
        特点:
            1.并行与并发:G1 能充分利用CPU、多核环境下的硬件优势,使用多个CPU或者CPU核心来缩短Stop-The-World停顿时间.
              部分其他收集器原本需要停顿 Java 线程执行的 GC 动作,G1 收集器仍然可以通过并发的方式让 java 程序继续执行.
            2.分代收集:虽然G1 可以不需要其他收集器配合就能独立管理整个GC堆,但是还是保留了分代的概念
            3.空间整合:G1 从整体来看是基于“标记-整理”算法实现的收集器,从局部上来看是基于“标记-复制”算法实现的.
            4.可预测的停顿:这是 G1 相对于 CMS 的另一个大优势,降低停顿时间是 G1 和 CMS 共同的关注点,
              G1 除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为 M 毫秒的时间片段内.
        运作步骤:初始标记 并发标记 最终标记 筛选回收
        G1 收集器在后台维护了一个优先列表,每次根据允许的收集时间,优先选择回收价值最大的Region
        这种使用 Region 划分内存空间以及有优先级的区域回收方式,保证了G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）.
   
