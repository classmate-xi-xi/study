# **GC**
##### **如何判断对象是否死亡**
    可达性算法
        GC Roots对象作为起点 寻找是否有可以到达Roots的引用链 如果没有说明对象可以被回收
        缓刑：可达性分析法中不可达的对象被第一次标记并且进行一次筛选,
        筛选的条件是此对象是否有必要执行finalize方法,当对象没有覆盖finalize方法,
        或finalize方法已经被虚拟机调用过时,虚拟机将这两种情况视为没有必要执行
    引用计数法 
        当前对象是否有被使用 有使用就将其计数器加一 引用失效就减一 当为0时就说明对象可以被回收
        循环引用问题 比如 a->b b->a 但除了他们之间的相互引用没有别的对象对他们进行引用

#####**强引用、软引用、弱引用、虚引用**
    强引用:
        以前我们使用的大部分引用实际上都是强引用,这是使用最普遍的引用.一个对象具有强引用,
        那就类似于必不可少的生活用品,垃圾回收器绝不会回收它.当内存空间不足,
        Java 虚拟机宁愿抛出 OutOfMemoryError 错误,使程序异常终止,
        也不会靠随意回收具有强引用的对象来解决内存不足问题.
    软引用:
        如果一个对象只具有软引用,那就类似于可有可无的生活用品.
        如果内存空间足够,垃圾回收器就不会回收它,如果内存空间不足了,就会回收这些对象的内存.
        只要垃圾回收器没有回收它,该对象就可以被程序使用.软引用可用来实现内存敏感的高速缓存.
        软引用可以和一个引用队列（ReferenceQueue）联合使用,
        如果软引用所引用的对象被垃圾回收,JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中.
    弱引用:
        弱引用与软引用的区别在于:只具有弱引用的对象拥有更短暂的生命周期.
        在垃圾回收器线程扫描它所管辖的内存区域的过程中,
        一旦发现了只具有弱引用的对象,不管当前内存空间足够与否,都会回收它的内存.
        不过,由于垃圾回收器是一个优先级很低的线程,因此不一定会很快发现那些只具有弱引用的对象.
        弱引用可以和一个引用队列（ReferenceQueue）联合使用,
        如果弱引用所引用的对象被垃圾回收,虚拟机就会把这个弱引用加入到与之关联的引用队列中.
    虚引用:
        就是形同虚设,与其他几种引用都不同,虚引用并不会决定对象的生命周期.
        如果一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收.
        虚引用主要用来跟踪对象被垃圾回收的活动.
        虚引用与软引用和弱引用的一个区别在于:虚引用必须和引用队列联合使用.当垃圾回收器准备回收一个对象时,
        如果发现它还有虚引用,就会在回收对象的内存之前,把这个虚引用加入到与之关联的引用队列中.
        程序可以通过判断引用队列中是否已经加入了虚引用,来了解被引用的对象是否将要被垃圾回收.
        程序如果发现某个虚引用已经被加入到引用队列,那么就可以在所引用的对象的内存被回收之前采取必要的行动.
        特别注意,在程序设计中一般很少使用弱引用与虚引用,使用软引用的情况较多,
        这是因为软引用可以加速JVM对垃圾内存的回收速度,
        可以维护系统的运行安全,防止内存溢出（OutOfMemory）等问题的产生.
#####**如何判断一个常量是废弃常量/如何判断一个类是无用的类**
    运行时常量池主要回收的是废弃的常量
        比如一个"abc"字符串,如果当前没有任何String对象引用其的话,就说明它是一个废弃常量
        在这时候如果发生了内存回收,那么它就会被清出常量池
    方法区主要回收的是无用的类
        类需要同时满足下面3个条件才能算是“无用的类”
        1.该类所有的实例都已经被回收,也就是 Java 堆中不存在该类的任何实例.
        2.加载该类的 ClassLoader 已经被回收.
        3.该类对应的 java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.
#####**垃圾收集器**
    
